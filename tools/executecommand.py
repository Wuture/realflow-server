import subprocess
import openai
from openai import OpenAI

client = OpenAI()

def generate_and_execute_applescript(description):
    """
    Generates AppleScript using OpenAI's GPT-4 Turbo and executes it.

    Args:
    description (str): A description of the task for which AppleScript is needed.

    Returns:
    dict: A dictionary containing the 'output' from executing the AppleScript or 'error' if it fails.
    """
    try:
        # Call to OpenAI's API to generate AppleScript
        response = client.chat.completions.create(
            model="gpt-4-turbo",
            messages=[{"role": "system", "content": f"Write an AppleScript that accomplishes the following task: {description}\n Only return the AppleScript code that is meant to be executed. Do not include any additional text or comments in the response including 'applescript'"}],
            max_tokens=150
        )

        # Extracting the script generated by the language model
        applescript_code = response.choices[0].message.content.strip()
        print("Generated AppleScript:", applescript_code)

        # Prepare the command to run the generated AppleScript using osascript
        command = ['osascript', '-e', applescript_code]

        # Execute the command
        print("Executing AppleScript:", command)
        result = subprocess.run(command, text=True, capture_output=True, check=True)
        return {"output": result.stdout}
    except subprocess.CalledProcessError as e:
        return {"error": e.stderr}
    except Exception as e:
        return {"error": str(e)}

# # Generate and execute other code snippets
# def generate_and_execute_python_code(description):
#     """
#     Generates python code using OpenAI's GPT-4 Turbo and executes it.

#     Args:
#     description (str): A description of the task for which code is needed.

#     Returns:
#     dict: A dictionary containing the 'output' from executing the code or 'error' if it fails.
#     """
#     try:
#         # Call to OpenAI's API to generate code
#         response = client.chat.completions.create(
#             model="gpt-4-turbo",
#             messages=[{"role": "system", "content": f"Write python code that accomplishes the following task: {description}\n Only return the code that is meant to be executed. Do not include any additional text or comments in the response"}],
#             max_tokens=150
#         )

#         # Extracting the code generated by the language model
#         code = response.choices[0].message.content.strip()
#         print("Generated code:", code)

#         # Execute the generated code
#         return execute_python_code(code)
#     except Exception as e:
#         return {"error": str(e)}

# # Excuted code snippets based on the extention type of the code (e.g. Python, JavaScript, etc.)
# def execute_python_code(code):
#     """
#     Executes a given python code snippet using subprocess and captures the output and any errors.

#     Args:
#     code (str): The code snippet to execute.

#     Returns:
#     dict: A dictionary containing the 'output' if the code was successful, or 'error' if it failed.
#     """
#     try:
#         # Write the code to a temporary file
#         with open("temp_code.py", "w") as file:
#             file.write(code)

#         # Prepare the command to run the code using Python
#         command = 'python temp_code.py'

#         # Execute the command
#         return execute_command(command)
#     except Exception as e:
#         return {"error": str(e)}

def execute_command(command):
    """
    Executes a given command line command using subprocess and captures the output and any errors.

    Args:
    command (list): The command to execute, provided as a list where the command and its arguments are separate items.

    Returns:
    dict: A dictionary containing the 'output' if the command was successful, or 'error' if it failed.
    """
    try:
        # Execute the command
        print("Executing command:", command)
        command_array = command.split()
        result = subprocess.run(command_array, text=True, capture_output=True, check=True)
        return {"output": result.stdout}
    except subprocess.CalledProcessError as e:
        return {"error": e.stderr}

